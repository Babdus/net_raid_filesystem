# NET RAID FILESYSTEM
ალექსანდრე აბრამიშვილი

## ზოგადი აღწერა

პროგრამა კომპილირდება make-ით, ქმნის ორ გაშვებად ფაილს: net_raid_client-სა და net_raid_servers და ეშვება შემდეგი ფორმით:

`./net_raid_client /path/to/configfile`

იმისათვის, რომ ამ პროგრამამ დაამაუნთოს კონფიგურაციის ფაილში გადმოცემული დირექტორიები, საჭიროა ასევე აქამდე გაშვებული იყოს კონფიგურაციის ფაილშივე გადმოცემული სერვერები შემდეგი ფორმით:

`./net_raid_server ip:port /path/to/storage/disk/`

მას შემდეგ რაც კლიენტი გაეშვება, იგი დაპარსავს კონფიგურაციის ფაილს და მასში მოცემულ თითოეული სანახისთვის ცალკე პროცესს შექმნის, რომელიც თავისმხრივ გამოიძახებს fuse-ის დამაუნთებას.

თუკი კონფიგურაციის ფაილში რამე შეცდომები აღმოჩნდა, შესაბამისი ტექსტური შეტყობინენები დაიბეჭდებატერმინალში. ხოლო მას შემდეგ, რაც კონფიგურაციის ფაილი სრულად დაიპარსება მასში მოცემულ ლოგირების ფაილშიც გაგრძელდება მნიშვნელოვანი მოვლენების ჩაწერა.

## RAID 1

რეიდ ერთის იმპლემენტაციისთვის fuse-ში გადავტვირთე შემდეგი სისტემური ბრძანებები:

* getattr
* mkdir
* mknod
* create
* rmdir
* unlink
* rename
* opendir
* open
* releasedir
* release
* readdir
* read
* write
* truncate
* utimens

რომელთაგანაც ნაწილი მხოლოდ ერთ სერვერზე სრულდება, ხოლო ნაწილი ყველა (ანუ ორ) სერვერზე. ერთსერვერიანი სისქოლებია getattr, opendir, readdir, releasedir, read, ორსერვერიანები კი დანარჩენი ყველა. open-ი ნაწილობრივ ერთსერვერიანია, ისეთ შემთხვევებში, როდესაც მხოლოდ წასაკითხად იხსნება ფაილი. utimens გადატვირთულია და ყოველთვის აბრუნებს 0-ს, იმისათვის რომ ფაილის შექმნას ერორი არ დაებრუნებინა.

როგორც რეიდ 1 გულისხმობს, ორივე სერვერი იდენტურია და ეს საშუალებას იძლევა ერთი სერვერის გითიშვა აიტანოს სისტემამ.
როდესაც ერთი სერვერი ითიშება, ყველა ოპერაცია ერთსერვერიანი ხდება და პარალელურად ლოგირების ფაილში იწერება გათიშული სერვერის შესახებ.

გარდა იმისა, რომ რეიდ 1-ს შეუძლია ერთი სერვერის გათიშვა აიტანოს, ასევე მას შეუძლია დაზიანებული ფაილების აღდგენა. ფაილები ჩაწერისას თითოეულ სერვერზე იჰეშება და ესეტება დამატებით ატრიბუტებში, ხოლო ყოველი გახსნისას მოწმდება ფაილის შიგთავსი და დარდება მის შენახულ ჰეშს. თუკი ჰეში სწორია, ყველაფერმა კარგად ჩაიარა და გრძელდება ოპერაციები შეუფერხებლად. არც ჰეშის დაუმთხვევლობაა ძალიან ცუდი, რადგან ამ შემთხვევაში მეორე სერვერზე იხსნება იგივე ფაილი და იგი მოწმდება თავისსავე ჰეშთან და თუკი სწორია, მაშინ ამ მეორე სერვერის ფაილის გადაწერა ხდება პირველ სერვერზე და ამის შემდეგ გრძელდება ყველაფერი ჩვეულებრივად. ამ მოვლენის დროსაც ლოგებში იწერება, რომ ფაილი დაზიანებული იყო. ერთადერთი სავალალო შემთხვევაა, როდესაც ორივე სერვერზე დაზიანებული ფაილები აღმოჩნდება, თუმცა ეს იმდენად დაბალალბათურია, რომ შეგვიძლია არ ვინერვიულოთ.

რეიდ 1-ის ამ იმპლემენტაციაში ნებისმიერი სტანდარტულ ფაილურ სისტემაზე ჩატარებადი ოპერაცია დასაშვებია: ფაილების შექმნა, დირექტორიების იერარქიული სტრუქტურის შექმნა, ჩაწერა/კითხვა, ნებისმიერი ედიტორით ფაილების გახსნა იქ დაედიტება და შემდეგ შენახვა, კოპირება, გადაადგილება და ა.შ.

ფაილების კოპირება, იმის გამო, რომ თითოეული მოქმედება სერვერზე გაგზავნას ნიშნავს, არაა ძალიან სწრაფი, თუმცა ატანადი სიჩქარისაა, დაახლოებით 25MB წამში - ერთი გიგაბაიტის გადაწერას 40 წამი დასჭირდა.

## RAID 5

რეიდ 5-ისთვის ზუსტად იგივე სისტემური ბრძანებები მაქვს გადატვირთული და ყველაფერი რეიდ1-ის იდენტურად მუშაობს, გარდა ოთხი სისქოლისა:

* getattr
* read
* write
* truncate

რადგან რეიდ 5-ში ფაილების შიგთავსი სხვადასხვა სერვერზე ნაწილდება და შესაბამისად თითოეულზე ფაილის საწყის ზომასთან შედარები პატარა ნაწილი იწერება, getattr-ის დაბრუნებული stat სტრუქტურა არასწორ ზომებს დააბრუნებდა და სწორედ ამის თავიდან ასარიდებლად შევცვალე ეს სისქოლი: მასში ზომის დასათვლელად ვაჯამებ ყველა სერვერზე ამ ფაილის ნაწილების ზომას და ვაკლებ მათში არსებულ parity ბლოკების ზომას.

ფაილების წაკითხვის დროს ვითვლი რომელ სერვერზე და რომელ სტრაიპზე აღმოჩნდება შესაბამისი ბლოკი და მას ვკითხულობ. წერისას კი გარდა იმის, რომ ასეთივე არითმეტიკით ვითვლი შესაბამის სერვერსა და სტრაიპს, ასევე ყოველი ჩაწერისას ვწერ parity ბლოკშიც ისეთნაირად, რომ ყველა დანარჩენი სერვერის იმავე სტრაიპის ქსორი გამოვიდეს: ვიღებ და ძველ ინფორმაციას (იმ ინფორმაციას, რომლის თავზე გადაწერა შემოგვივიდა ბრძანებად) გადავქსორავ parity-ს შესაბამის ადგილზე, ამით ვაბათილებ parity ბლოკში ძველ ინფორმაციას, შემდეგ კი ამას გადავქსორავ ახალ ინფორმაციაზე და ჩავწერ parity-ზე. ამ მეთოდით ყოველთვის სწორად დარჩება parity ბლოკები დანარჩენი ყველა სერვერის იმავე სტრაიპის ქსორები.

truncate-ც საჭირო იყო შეცვლილიყო, რადგან იგი ზომას უთითებს ფაილს, ხოლო აქ ფაილები ნაგულისხმებ ზომასთან შედარებით პატარებია და გარკვეული კანონზომიერებით. truncate-ც სწორად იმას შვება, რომ შემდეგ ამ ფაილების ზომების დაჯამებით და parity ბლოკების გამოკლებით ზუსტად ის ზომა მივიღოთ, რომელიც გადმოგვეცა ფაილის ზომის განსასაზღვრად.

მიუხედავად იმისა, რომ რეიდ 5-ში იდენტური სერვერები არ გვაქვს, მაინც შეგვიძლია ავიტანოთ ერთი სერვერის გათიშვა, და ამ დროს ზემოთ ჩამოთვლილი ფუნქციები მაინც მუშაობდნენ სწორად. იმის გამო, რომ ყოველ სტრაიპში გვაქვს ერთი parity ბლოკი, რომელიც დანარჩენების ქსორია, რომელი სერვერიც არ უნდა გაითიშოს, დანარჩენი ყველას ერთმანეთზე გადაქსორვით შეგვიძლია აღვადგინოთ რა იქნებოდა იმ გათიშულ სერვერზე. ეს წაკითხვის დროს, ხოლო ჩაწერისას გათიშული სერვერის მაგივრად ჩაწერა მოხდება მხოლოდ parity ბლოკზე, თითქოს არც ყოფილიყო გათიშული სერვერი. ეს ჩაწერის პრინციპი ძალიან მსგავსია გაუთიშავი სერვერების შემთხვევაში არსებული პრინციპისა, ერთადერთი განსხვავებით, რომ ამ შემთხვევაში პირდაპირ არ გვაქვს ძველი ინფორმაცია, რომელსაც ერთ-ერთ ელემენტად ვიყენებდით გადაქსორვებისას, თუმცა შეგვიძლია მისი აღდგენა, თუ გადავქსორავთ ამ სტრაიპის ყველა დანარჩენ ბლოკთან. შემდეგ კი იმავე ალგორითმით ვცვლით parity ბლოკს, რის მეშვეობითაც ისევ შეგვიძლია ამ ჩაწერილი ინფორმაციის წაკითხვა.

სტრაიპის ზომა დამოკიდებული იმაზე, თუ რამდენი სერვერი იქნება, რადგან ბლოკის ზომაა ფიქსირებული, 256 ბაიტი, რომელიც ოპტიმალური აღმოჩნდა ბევრ შემთხვევაში.

რეიდ 5-საც აქვს ყველა ის სტანდარტული ფუნქცია, რომელიც რეიდ 1-ს ჰქონდა, თუმცა მასში წერა/კითხვა ბევრად ნელი ოპერაციაა მუდმივი გადაქსორვების გამო და ფაილის დაკოპირების სიჩქარე დაახლოებით 8MB წამშია. თუმცა გიგაბაიტინი ფაილის გადაწერა მაინც ადეკვატურ დროში ხორციელდება.

## ლოგირება

ლოგების ფაილში იწერება ძირითადი მოვლენები, როგორებიცაა:

* სერვერთან შეერთება

    (NRF)[05:16:13:474374 Thursday, 02 August 2018] Success: STORAGE2: 127.0.0.1:10011 server is connected

* სერვერთან ვერ შეერთება

    (NRF)[05:16:14:878903 Thursday, 02 August 2018]   Error: STORAGE2: 127.0.0.1:10011 can not connect to server

* სერვერის დაკარგულად გამოცხადება

    (NRF)[05:16:36:248306 Thursday, 02 August 2018]   Error: STORAGE1: 127.0.0.1:10001 server declared as lost

* ფაილის დაზიანების აღმოჩენა

    (NRF)[05:17:00:799692 Thursday, 02 August 2018]   Error: STORAGE1: 127.0.0.1:10002 server has damaged file

* ფაილის წარმატებით აღდგენა

    (NRF)[05:17:10:365637 Thursday, 02 August 2018]   Error: STORAGE2: 127.0.0.1:10012 the file is recovered from another server

* ორი ან მეტი სერვერის გათიშვის შეთხვევაში სისტემა წყვეტს მუშაობას

    (NRF)[05:17:29:553403 Thursday, 02 August 2018]   Error: STORAGE2: 127.0.0.1:10012 more than one server is dead!

ჩემი რჩევა იქნება ლოგები ნახოთ პირდაპირ ტერმინალში, მაგალითად more ბრძანებით, რადგან ფერადად დაიბეჭდება.